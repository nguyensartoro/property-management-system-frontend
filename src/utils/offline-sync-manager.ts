// Comprehensive offline sync manager for mobile app\n\nimport { offlineStorage, offlineAPI, networkStatus } from './offline-storage';\nimport { pushNotifications, NotificationTemplates } from './push-notifications';\n\ninterface SyncQueueItem {\n  id: string;\n  type: 'create' | 'update' | 'delete';\n  entity: string;\n  data: any;\n  endpoint: string;\n  method: string;\n  timestamp: number;\n  retryCount: number;\n  maxRetries: number;\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  dependencies?: string[];\n  metadata?: {\n    userId?: string;\n    propertyId?: string;\n    tenantId?: string;\n    [key: string]: any;\n  };\n}\n\ninterface SyncResult {\n  success: boolean;\n  itemId: string;\n  error?: string;\n  serverResponse?: any;\n}\n\ninterface SyncStatus {\n  isOnline: boolean;\n  isSyncing: boolean;\n  lastSyncTime: Date | null;\n  pendingItems: number;\n  failedItems: number;\n  totalSynced: number;\n  errors: string[];\n}\n\ninterface ConflictResolution {\n  strategy: 'client-wins' | 'server-wins' | 'merge' | 'manual';\n  resolver?: (clientData: any, serverData: any) => any;\n}\n\nclass OfflineSyncManager {\n  private syncQueue: SyncQueueItem[] = [];\n  private isCurrentlySyncing = false;\n  private syncListeners: Array<(status: SyncStatus) => void> = [];\n  private conflictResolvers: Map<string, ConflictResolution> = new Map();\n  private syncStatus: SyncStatus = {\n    isOnline: navigator.onLine,\n    isSyncing: false,\n    lastSyncTime: null,\n    pendingItems: 0,\n    failedItems: 0,\n    totalSynced: 0,\n    errors: [],\n  };\n\n  constructor() {\n    this.initializeSync();\n    this.setupNetworkListeners();\n    this.loadSyncQueue();\n    this.setupConflictResolvers();\n  }\n\n  /**\n   * Initialize sync manager\n   */\n  private async initializeSync(): Promise<void> {\n    try {\n      // Load last sync time from storage\n      const lastSync = await offlineStorage.getCache<string>('last-sync-time');\n      if (lastSync) {\n        this.syncStatus.lastSyncTime = new Date(lastSync);\n      }\n\n      // Start periodic sync if online\n      if (navigator.onLine) {\n        this.startPeriodicSync();\n      }\n    } catch (error) {\n      console.error('Error initializing sync manager:', error);\n    }\n  }\n\n  /**\n   * Setup network status listeners\n   */\n  private setupNetworkListeners(): void {\n    networkStatus.addListener((isOnline) => {\n      this.syncStatus.isOnline = isOnline;\n      this.notifyListeners();\n\n      if (isOnline) {\n        // Trigger sync when coming back online\n        this.triggerSync();\n        this.startPeriodicSync();\n      } else {\n        this.stopPeriodicSync();\n      }\n    });\n  }\n\n  /**\n   * Load sync queue from storage\n   */\n  private async loadSyncQueue(): Promise<void> {\n    try {\n      const queue = await offlineStorage.getCache<SyncQueueItem[]>('sync-queue');\n      if (queue) {\n        this.syncQueue = queue;\n        this.updateSyncStatus();\n      }\n    } catch (error) {\n      console.error('Error loading sync queue:', error);\n    }\n  }\n\n  /**\n   * Save sync queue to storage\n   */\n  private async saveSyncQueue(): Promise<void> {\n    try {\n      await offlineStorage.setCache('sync-queue', this.syncQueue);\n      this.updateSyncStatus();\n    } catch (error) {\n      console.error('Error saving sync queue:', error);\n    }\n  }\n\n  /**\n   * Setup default conflict resolvers\n   */\n  private setupConflictResolvers(): void {\n    // Property updates - server wins for critical data\n    this.conflictResolvers.set('properties', {\n      strategy: 'server-wins',\n    });\n\n    // Tenant data - merge strategy\n    this.conflictResolvers.set('tenants', {\n      strategy: 'merge',\n      resolver: (client, server) => ({\n        ...server,\n        // Keep client preferences if they exist\n        preferences: client.preferences || server.preferences,\n        // Keep client notes if more recent\n        notes: client.updatedAt > server.updatedAt ? client.notes : server.notes,\n      }),\n    });\n\n    // Maintenance requests - client wins for status updates\n    this.conflictResolvers.set('maintenance', {\n      strategy: 'client-wins',\n    });\n\n    // Payments - server wins (financial data)\n    this.conflictResolvers.set('payments', {\n      strategy: 'server-wins',\n    });\n\n    // Messages - merge strategy\n    this.conflictResolvers.set('messages', {\n      strategy: 'merge',\n      resolver: (client, server) => ({\n        ...server,\n        readStatus: client.readStatus || server.readStatus,\n        starred: client.starred !== undefined ? client.starred : server.starred,\n      }),\n    });\n  }\n\n  /**\n   * Add item to sync queue\n   */\n  async addToSyncQueue(\n    type: 'create' | 'update' | 'delete',\n    entity: string,\n    data: any,\n    options: {\n      endpoint: string;\n      method: string;\n      priority?: 'low' | 'medium' | 'high' | 'critical';\n      dependencies?: string[];\n      metadata?: any;\n    }\n  ): Promise<string> {\n    const item: SyncQueueItem = {\n      id: `sync_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      type,\n      entity,\n      data,\n      endpoint: options.endpoint,\n      method: options.method,\n      timestamp: Date.now(),\n      retryCount: 0,\n      maxRetries: this.getMaxRetries(options.priority || 'medium'),\n      priority: options.priority || 'medium',\n      dependencies: options.dependencies,\n      metadata: options.metadata,\n    };\n\n    this.syncQueue.push(item);\n    await this.saveSyncQueue();\n\n    // Trigger immediate sync for critical items if online\n    if (item.priority === 'critical' && navigator.onLine) {\n      this.triggerSync();\n    }\n\n    return item.id;\n  }\n\n  /**\n   * Get max retries based on priority\n   */\n  private getMaxRetries(priority: string): number {\n    switch (priority) {\n      case 'critical':\n        return 10;\n      case 'high':\n        return 5;\n      case 'medium':\n        return 3;\n      case 'low':\n        return 1;\n      default:\n        return 3;\n    }\n  }\n\n  /**\n   * Trigger sync process\n   */\n  async triggerSync(): Promise<void> {\n    if (!navigator.onLine || this.isCurrentlySyncing || this.syncQueue.length === 0) {\n      return;\n    }\n\n    this.isCurrentlySyncing = true;\n    this.syncStatus.isSyncing = true;\n    this.notifyListeners();\n\n    try {\n      await this.performSync();\n    } catch (error) {\n      console.error('Sync error:', error);\n      this.syncStatus.errors.push(error instanceof Error ? error.message : 'Unknown sync error');\n    } finally {\n      this.isCurrentlySyncing = false;\n      this.syncStatus.isSyncing = false;\n      this.syncStatus.lastSyncTime = new Date();\n      await offlineStorage.setCache('last-sync-time', this.syncStatus.lastSyncTime.toISOString());\n      this.notifyListeners();\n    }\n  }\n\n  /**\n   * Perform the actual sync process\n   */\n  private async performSync(): Promise<void> {\n    // Sort queue by priority and dependencies\n    const sortedQueue = this.sortSyncQueue();\n    const results: SyncResult[] = [];\n\n    for (const item of sortedQueue) {\n      try {\n        // Check if dependencies are satisfied\n        if (!this.areDependenciesSatisfied(item, results)) {\n          continue;\n        }\n\n        const result = await this.syncItem(item);\n        results.push(result);\n\n        if (result.success) {\n          // Remove from queue\n          this.syncQueue = this.syncQueue.filter(queueItem => queueItem.id !== item.id);\n          this.syncStatus.totalSynced++;\n        } else {\n          // Increment retry count\n          item.retryCount++;\n          if (item.retryCount >= item.maxRetries) {\n            // Remove failed item after max retries\n            this.syncQueue = this.syncQueue.filter(queueItem => queueItem.id !== item.id);\n            this.syncStatus.failedItems++;\n            this.syncStatus.errors.push(`Failed to sync ${item.entity} after ${item.maxRetries} retries`);\n          }\n        }\n      } catch (error) {\n        console.error(`Error syncing item ${item.id}:`, error);\n        item.retryCount++;\n      }\n    }\n\n    await this.saveSyncQueue();\n\n    // Show sync completion notification\n    if (results.length > 0) {\n      const successCount = results.filter(r => r.success).length;\n      const failureCount = results.filter(r => !r.success).length;\n\n      if (successCount > 0) {\n        await pushNotifications.showNotification({\n          title: 'Sync Complete',\n          body: `${successCount} items synced successfully${failureCount > 0 ? `, ${failureCount} failed` : ''}`,\n          icon: '/icons/sync-icon.png',\n          tag: 'sync-complete',\n          data: { type: 'sync', successCount, failureCount },\n        });\n      }\n    }\n  }\n\n  /**\n   * Sort sync queue by priority and dependencies\n   */\n  private sortSyncQueue(): SyncQueueItem[] {\n    const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };\n    \n    return [...this.syncQueue].sort((a, b) => {\n      // First sort by priority\n      const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];\n      if (priorityDiff !== 0) return priorityDiff;\n      \n      // Then by timestamp (older first)\n      return a.timestamp - b.timestamp;\n    });\n  }\n\n  /**\n   * Check if item dependencies are satisfied\n   */\n  private areDependenciesSatisfied(item: SyncQueueItem, results: SyncResult[]): boolean {\n    if (!item.dependencies || item.dependencies.length === 0) {\n      return true;\n    }\n\n    return item.dependencies.every(depId => \n      results.some(result => result.itemId === depId && result.success)\n    );\n  }\n\n  /**\n   * Sync individual item\n   */\n  private async syncItem(item: SyncQueueItem): Promise<SyncResult> {\n    try {\n      const response = await fetch(item.endpoint, {\n        method: item.method,\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.getAuthToken()}`,\n        },\n        body: item.method !== 'GET' ? JSON.stringify(item.data) : undefined,\n      });\n\n      if (!response.ok) {\n        // Handle conflicts (409)\n        if (response.status === 409) {\n          const serverData = await response.json();\n          const resolvedData = await this.resolveConflict(item, serverData);\n          \n          if (resolvedData) {\n            // Retry with resolved data\n            const retryResponse = await fetch(item.endpoint, {\n              method: item.method,\n              headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${this.getAuthToken()}`,\n              },\n              body: JSON.stringify(resolvedData),\n            });\n            \n            if (retryResponse.ok) {\n              const result = await retryResponse.json();\n              await this.updateLocalData(item.entity, item.data.id, result);\n              return { success: true, itemId: item.id, serverResponse: result };\n            }\n          }\n        }\n        \n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      \n      // Update local data with server response\n      if (item.type === 'create' || item.type === 'update') {\n        await this.updateLocalData(item.entity, item.data.id, result);\n      } else if (item.type === 'delete') {\n        await this.removeLocalData(item.entity, item.data.id);\n      }\n\n      return { success: true, itemId: item.id, serverResponse: result };\n    } catch (error) {\n      return {\n        success: false,\n        itemId: item.id,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * Resolve data conflicts\n   */\n  private async resolveConflict(item: SyncQueueItem, serverData: any): Promise<any | null> {\n    const resolver = this.conflictResolvers.get(item.entity);\n    \n    if (!resolver) {\n      // Default to server wins\n      return serverData;\n    }\n\n    switch (resolver.strategy) {\n      case 'client-wins':\n        return item.data;\n      \n      case 'server-wins':\n        return serverData;\n      \n      case 'merge':\n        if (resolver.resolver) {\n          return resolver.resolver(item.data, serverData);\n        }\n        return { ...serverData, ...item.data };\n      \n      case 'manual':\n        // Show conflict resolution UI to user\n        return await this.showConflictResolutionUI(item.data, serverData);\n      \n      default:\n        return serverData;\n    }\n  }\n\n  /**\n   * Show conflict resolution UI (placeholder)\n   */\n  private async showConflictResolutionUI(clientData: any, serverData: any): Promise<any> {\n    // This would show a UI for manual conflict resolution\n    // For now, default to server wins\n    console.log('Manual conflict resolution needed:', { clientData, serverData });\n    return serverData;\n  }\n\n  /**\n   * Update local data with server response\n   */\n  private async updateLocalData(entity: string, id: string, data: any): Promise<void> {\n    try {\n      await offlineStorage.storeEntity(entity, data);\n      \n      // Update cache if it exists\n      const cacheKey = `${entity}_${id}`;\n      await offlineStorage.setCache(cacheKey, data, 60); // Cache for 1 hour\n    } catch (error) {\n      console.error('Error updating local data:', error);\n    }\n  }\n\n  /**\n   * Remove local data\n   */\n  private async removeLocalData(entity: string, id: string): Promise<void> {\n    try {\n      // This would need to be implemented in the storage manager\n      // For now, just remove from cache\n      const cacheKey = `${entity}_${id}`;\n      await offlineStorage.deleteCache(cacheKey);\n    } catch (error) {\n      console.error('Error removing local data:', error);\n    }\n  }\n\n  /**\n   * Get auth token\n   */\n  private getAuthToken(): string {\n    return localStorage.getItem('authToken') || '';\n  }\n\n  /**\n   * Start periodic sync\n   */\n  private startPeriodicSync(): void {\n    // Sync every 5 minutes when online\n    setInterval(() => {\n      if (navigator.onLine && !this.isCurrentlySyncing) {\n        this.triggerSync();\n      }\n    }, 5 * 60 * 1000);\n  }\n\n  /**\n   * Stop periodic sync\n   */\n  private stopPeriodicSync(): void {\n    // Implementation would clear the interval\n    // For now, just a placeholder\n  }\n\n  /**\n   * Update sync status\n   */\n  private updateSyncStatus(): void {\n    this.syncStatus.pendingItems = this.syncQueue.length;\n    this.notifyListeners();\n  }\n\n  /**\n   * Add sync status listener\n   */\n  addSyncListener(listener: (status: SyncStatus) => void): void {\n    this.syncListeners.push(listener);\n  }\n\n  /**\n   * Remove sync status listener\n   */\n  removeSyncListener(listener: (status: SyncStatus) => void): void {\n    const index = this.syncListeners.indexOf(listener);\n    if (index > -1) {\n      this.syncListeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Notify all listeners\n   */\n  private notifyListeners(): void {\n    this.syncListeners.forEach(listener => listener({ ...this.syncStatus }));\n  }\n\n  /**\n   * Get current sync status\n   */\n  getSyncStatus(): SyncStatus {\n    return { ...this.syncStatus };\n  }\n\n  /**\n   * Clear sync queue\n   */\n  async clearSyncQueue(): Promise<void> {\n    this.syncQueue = [];\n    await this.saveSyncQueue();\n  }\n\n  /**\n   * Get pending sync items\n   */\n  getPendingSyncItems(): SyncQueueItem[] {\n    return [...this.syncQueue];\n  }\n\n  /**\n   * Force sync specific item\n   */\n  async forceSyncItem(itemId: string): Promise<boolean> {\n    const item = this.syncQueue.find(i => i.id === itemId);\n    if (!item || !navigator.onLine) {\n      return false;\n    }\n\n    try {\n      const result = await this.syncItem(item);\n      if (result.success) {\n        this.syncQueue = this.syncQueue.filter(i => i.id !== itemId);\n        await this.saveSyncQueue();\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Error force syncing item:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Set conflict resolver for entity\n   */\n  setConflictResolver(entity: string, resolver: ConflictResolution): void {\n    this.conflictResolvers.set(entity, resolver);\n  }\n\n  /**\n   * Get sync statistics\n   */\n  getSyncStatistics(): {\n    totalPending: number;\n    totalFailed: number;\n    totalSynced: number;\n    byPriority: Record<string, number>;\n    byEntity: Record<string, number>;\n  } {\n    const byPriority: Record<string, number> = {};\n    const byEntity: Record<string, number> = {};\n\n    this.syncQueue.forEach(item => {\n      byPriority[item.priority] = (byPriority[item.priority] || 0) + 1;\n      byEntity[item.entity] = (byEntity[item.entity] || 0) + 1;\n    });\n\n    return {\n      totalPending: this.syncStatus.pendingItems,\n      totalFailed: this.syncStatus.failedItems,\n      totalSynced: this.syncStatus.totalSynced,\n      byPriority,\n      byEntity,\n    };\n  }\n}\n\n// Export singleton instance\nexport const offlineSyncManager = new OfflineSyncManager();\n\n// React hook for sync status\nexport const useSyncStatus = () => {\n  const [status, setStatus] = React.useState<SyncStatus>(offlineSyncManager.getSyncStatus());\n\n  React.useEffect(() => {\n    const handleStatusChange = (newStatus: SyncStatus) => {\n      setStatus(newStatus);\n    };\n\n    offlineSyncManager.addSyncListener(handleStatusChange);\n    \n    return () => {\n      offlineSyncManager.removeSyncListener(handleStatusChange);\n    };\n  }, []);\n\n  const triggerSync = React.useCallback(() => {\n    offlineSyncManager.triggerSync();\n  }, []);\n\n  const clearQueue = React.useCallback(() => {\n    offlineSyncManager.clearSyncQueue();\n  }, []);\n\n  const forceSyncItem = React.useCallback((itemId: string) => {\n    return offlineSyncManager.forceSyncItem(itemId);\n  }, []);\n\n  return {\n    status,\n    triggerSync,\n    clearQueue,\n    forceSyncItem,\n    statistics: offlineSyncManager.getSyncStatistics(),\n    pendingItems: offlineSyncManager.getPendingSyncItems(),\n  };\n};\n\n// Import React for the hook\nimport React from 'react';\n"