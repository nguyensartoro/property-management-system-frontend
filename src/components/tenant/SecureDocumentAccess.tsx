import React, { useState, useEffect, useCallback } from 'react';\nimport {\n  Box,\n  Card,\n  CardContent,\n  Typography,\n  TextField,\n  Button,\n  Chip,\n  Grid,\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogActions,\n  List,\n  ListItem,\n  ListItemText,\n  ListItemIcon,\n  ListItemSecondaryAction,\n  IconButton,\n  Menu,\n  MenuItem,\n  Tabs,\n  Tab,\n  Badge,\n  Tooltip,\n  CircularProgress,\n  Alert,\n  Snackbar,\n  FormControl,\n  InputLabel,\n  Select,\n  Divider,\n  Avatar,\n  Paper\n} from '@mui/material';\nimport {\n  Search as SearchIcon,\n  Download as DownloadIcon,\n  Visibility as ViewIcon,\n  Comment as CommentIcon,\n  Share as ShareIcon,\n  History as HistoryIcon,\n  FilterList as FilterIcon,\n  Description as DocumentIcon,\n  Image as ImageIcon,\n  PictureAsPdf as PdfIcon,\n  InsertDriveFile as FileIcon,\n  MoreVert as MoreVertIcon,\n  Send as SendIcon,\n  Close as CloseIcon,\n  Folder as FolderIcon,\n  Schedule as ScheduleIcon,\n  Person as PersonIcon,\n  Security as SecurityIcon\n} from '@mui/icons-material';\nimport { format } from 'date-fns';\n\ninterface Document {\n  id: string;\n  name: string;\n  type: string;\n  category: 'lease' | 'financial' | 'maintenance' | 'legal' | 'personal' | 'property' | 'insurance';\n  size: number;\n  url: string;\n  thumbnailUrl?: string;\n  uploadedAt: Date;\n  uploadedBy: string;\n  isShared: boolean;\n  accessLevel: 'read' | 'download' | 'full';\n  expiresAt?: Date;\n  metadata: Record<string, any>;\n  tags: string[];\n  version: number;\n  parentDocumentId?: string;\n  isEncrypted: boolean;\n}\n\ninterface DocumentComment {\n  id: string;\n  documentId: string;\n  userId: string;\n  userType: 'tenant' | 'manager' | 'admin';\n  comment: string;\n  createdAt: Date;\n  updatedAt: Date;\n  isPrivate: boolean;\n  parentCommentId?: string;\n  attachments?: string[];\n}\n\ninterface DocumentCategory {\n  category: string;\n  count: number;\n  lastUpdated: Date;\n}\n\ninterface SearchFilters {\n  category?: string;\n  type?: string;\n  tags?: string[];\n  dateRange?: {\n    start: Date;\n    end: Date;\n  };\n  sortBy?: 'name' | 'date' | 'size' | 'relevance';\n  sortOrder?: 'asc' | 'desc';\n}\n\nconst SecureDocumentAccess: React.FC = () => {\n  const [documents, setDocuments] = useState<Document[]>([]);\n  const [categories, setCategories] = useState<DocumentCategory[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [filters, setFilters] = useState<SearchFilters>({});\n  const [selectedDocument, setSelectedDocument] = useState<Document | null>(null);\n  const [documentComments, setDocumentComments] = useState<DocumentComment[]>([]);\n  const [newComment, setNewComment] = useState('');\n  const [activeTab, setActiveTab] = useState(0);\n  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\n  const [selectedDocumentForMenu, setSelectedDocumentForMenu] = useState<Document | null>(null);\n  const [showFilters, setShowFilters] = useState(false);\n  const [showDocumentDialog, setShowDocumentDialog] = useState(false);\n  const [showCommentsDialog, setShowCommentsDialog] = useState(false);\n  const [showShareDialog, setShowShareDialog] = useState(false);\n  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' as 'success' | 'error' | 'info' | 'warning' });\n  const [pagination, setPagination] = useState({ limit: 20, offset: 0, total: 0, hasMore: false });\n\n  // Load documents on component mount\n  useEffect(() => {\n    loadDocuments();\n    loadCategories();\n  }, [filters, pagination.offset]);\n\n  const loadDocuments = async () => {\n    setLoading(true);\n    try {\n      const queryParams = new URLSearchParams({\n        limit: pagination.limit.toString(),\n        offset: pagination.offset.toString(),\n        ...(filters.category && { category: filters.category }),\n        ...(filters.type && { type: filters.type }),\n        ...(filters.tags && { tags: filters.tags.join(',') }),\n        ...(filters.dateRange && {\n          startDate: filters.dateRange.start.toISOString(),\n          endDate: filters.dateRange.end.toISOString()\n        }),\n        ...(filters.sortBy && { sortBy: filters.sortBy }),\n        ...(filters.sortOrder && { sortOrder: filters.sortOrder })\n      });\n\n      const response = await fetch(`/api/tenant-document-communication/documents?${queryParams}`, {\n        headers: {\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to load documents');\n      }\n\n      const data = await response.json();\n      setDocuments(data.data.documents);\n      setPagination(prev => ({\n        ...prev,\n        total: data.data.total,\n        hasMore: data.data.hasMore\n      }));\n    } catch (error) {\n      console.error('Error loading documents:', error);\n      setSnackbar({\n        open: true,\n        message: 'Failed to load documents',\n        severity: 'error'\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const loadCategories = async () => {\n    try {\n      const response = await fetch('/api/tenant-document-communication/documents/categories', {\n        headers: {\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to load categories');\n      }\n\n      const data = await response.json();\n      setCategories(data.data);\n    } catch (error) {\n      console.error('Error loading categories:', error);\n    }\n  };\n\n  const searchDocuments = async () => {\n    if (!searchTerm.trim()) {\n      loadDocuments();\n      return;\n    }\n\n    setLoading(true);\n    try {\n      const queryParams = new URLSearchParams({\n        q: searchTerm,\n        limit: pagination.limit.toString(),\n        offset: '0',\n        ...(filters.category && { category: filters.category }),\n        ...(filters.type && { type: filters.type }),\n        ...(filters.tags && { tags: filters.tags.join(',') }),\n        ...(filters.sortBy && { sortBy: filters.sortBy }),\n        ...(filters.sortOrder && { sortOrder: filters.sortOrder })\n      });\n\n      const response = await fetch(`/api/tenant-document-communication/documents/search?${queryParams}`, {\n        headers: {\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to search documents');\n      }\n\n      const data = await response.json();\n      setDocuments(data.data.documents);\n      setPagination(prev => ({\n        ...prev,\n        offset: 0,\n        total: data.data.total,\n        hasMore: data.data.hasMore\n      }));\n    } catch (error) {\n      console.error('Error searching documents:', error);\n      setSnackbar({\n        open: true,\n        message: 'Failed to search documents',\n        severity: 'error'\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const downloadDocument = async (document: Document) => {\n    if (document.accessLevel === 'read') {\n      setSnackbar({\n        open: true,\n        message: 'Download not permitted for this document',\n        severity: 'warning'\n      });\n      return;\n    }\n\n    try {\n      const response = await fetch(`/api/tenant-document-communication/documents/${document.id}/download`, {\n        headers: {\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to download document');\n      }\n\n      const data = await response.json();\n      \n      // Create download link\n      const link = document.createElement('a');\n      link.href = data.data.url;\n      link.download = data.data.filename;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n\n      setSnackbar({\n        open: true,\n        message: 'Document download started',\n        severity: 'success'\n      });\n    } catch (error) {\n      console.error('Error downloading document:', error);\n      setSnackbar({\n        open: true,\n        message: 'Failed to download document',\n        severity: 'error'\n      });\n    }\n  };\n\n  const viewDocument = (document: Document) => {\n    setSelectedDocument(document);\n    setShowDocumentDialog(true);\n  };\n\n  const loadDocumentComments = async (documentId: string) => {\n    try {\n      const response = await fetch(`/api/tenant-document-communication/documents/${documentId}/comments`, {\n        headers: {\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to load comments');\n      }\n\n      const data = await response.json();\n      setDocumentComments(data.data);\n    } catch (error) {\n      console.error('Error loading comments:', error);\n      setSnackbar({\n        open: true,\n        message: 'Failed to load comments',\n        severity: 'error'\n      });\n    }\n  };\n\n  const addComment = async () => {\n    if (!selectedDocument || !newComment.trim()) return;\n\n    try {\n      const response = await fetch(`/api/tenant-document-communication/documents/${selectedDocument.id}/comments`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\n        },\n        body: JSON.stringify({\n          comment: newComment.trim(),\n          isPrivate: false\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to add comment');\n      }\n\n      setNewComment('');\n      loadDocumentComments(selectedDocument.id);\n      setSnackbar({\n        open: true,\n        message: 'Comment added successfully',\n        severity: 'success'\n      });\n    } catch (error) {\n      console.error('Error adding comment:', error);\n      setSnackbar({\n        open: true,\n        message: 'Failed to add comment',\n        severity: 'error'\n      });\n    }\n  };\n\n  const getDocumentIcon = (document: Document) => {\n    if (document.type.includes('pdf')) return <PdfIcon />;\n    if (document.type.includes('image')) return <ImageIcon />;\n    return <FileIcon />;\n  };\n\n  const formatFileSize = (bytes: number) => {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  };\n\n  const getCategoryColor = (category: string) => {\n    const colors: Record<string, string> = {\n      lease: '#2196F3',\n      financial: '#4CAF50',\n      maintenance: '#FF9800',\n      legal: '#9C27B0',\n      personal: '#607D8B',\n      property: '#795548',\n      insurance: '#F44336'\n    };\n    return colors[category] || '#757575';\n  };\n\n  const handleMenuClick = (event: React.MouseEvent<HTMLElement>, document: Document) => {\n    setAnchorEl(event.currentTarget);\n    setSelectedDocumentForMenu(document);\n  };\n\n  const handleMenuClose = () => {\n    setAnchorEl(null);\n    setSelectedDocumentForMenu(null);\n  };\n\n  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {\n    setActiveTab(newValue);\n  };\n\n  const TabPanel = ({ children, value, index }: { children: React.ReactNode; value: number; index: number }) => (\n    <div hidden={value !== index}>\n      {value === index && <Box sx={{ p: 3 }}>{children}</Box>}\n    </div>\n  );\n\n  return (\n    <Box sx={{ p: 3 }}>\n      <Typography variant=\"h4\" gutterBottom>\n        Document Access\n        {documents.some(doc => doc.isEncrypted) && (\n          <Tooltip title=\"Some documents are encrypted for security\">\n            <SecurityIcon sx={{ ml: 1, color: 'primary.main' }} />\n          </Tooltip>\n        )}\n      </Typography>\n\n      {/* Search and Filters */}\n      <Card sx={{ mb: 3 }}>\n        <CardContent>\n          <Grid container spacing={2} alignItems=\"center\">\n            <Grid item xs={12} md={6}>\n              <TextField\n                fullWidth\n                placeholder=\"Search documents...\"\n                value={searchTerm}\n                onChange={(e) => setSearchTerm(e.target.value)}\n                onKeyPress={(e) => e.key === 'Enter' && searchDocuments()}\n                InputProps={{\n                  startAdornment: <SearchIcon sx={{ mr: 1, color: 'text.secondary' }} />\n                }}\n              />\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <Button\n                variant=\"contained\"\n                onClick={searchDocuments}\n                startIcon={<SearchIcon />}\n                fullWidth\n              >\n                Search\n              </Button>\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <Button\n                variant=\"outlined\"\n                onClick={() => setShowFilters(!showFilters)}\n                startIcon={<FilterIcon />}\n                fullWidth\n              >\n                Filters\n              </Button>\n            </Grid>\n          </Grid>\n\n          {/* Filter Panel */}\n          {showFilters && (\n            <Box sx={{ mt: 2, p: 2, bgcolor: 'grey.50', borderRadius: 1 }}>\n              <Grid container spacing={2}>\n                <Grid item xs={12} md={4}>\n                  <FormControl fullWidth>\n                    <InputLabel>Category</InputLabel>\n                    <Select\n                      value={filters.category || ''}\n                      onChange={(e) => setFilters({ ...filters, category: e.target.value })}\n                    >\n                      <MenuItem value=\"\">All Categories</MenuItem>\n                      {categories.map((cat) => (\n                        <MenuItem key={cat.category} value={cat.category}>\n                          {cat.category} ({cat.count})\n                        </MenuItem>\n                      ))}\n                    </Select>\n                  </FormControl>\n                </Grid>\n                <Grid item xs={12} md={4}>\n                  <FormControl fullWidth>\n                    <InputLabel>Sort By</InputLabel>\n                    <Select\n                      value={filters.sortBy || 'date'}\n                      onChange={(e) => setFilters({ ...filters, sortBy: e.target.value as any })}\n                    >\n                      <MenuItem value=\"date\">Date</MenuItem>\n                      <MenuItem value=\"name\">Name</MenuItem>\n                      <MenuItem value=\"size\">Size</MenuItem>\n                    </Select>\n                  </FormControl>\n                </Grid>\n                <Grid item xs={12} md={4}>\n                  <FormControl fullWidth>\n                    <InputLabel>Order</InputLabel>\n                    <Select\n                      value={filters.sortOrder || 'desc'}\n                      onChange={(e) => setFilters({ ...filters, sortOrder: e.target.value as any })}\n                    >\n                      <MenuItem value=\"desc\">Newest First</MenuItem>\n                      <MenuItem value=\"asc\">Oldest First</MenuItem>\n                    </Select>\n                  </FormControl>\n                </Grid>\n              </Grid>\n            </Box>\n          )}\n        </CardContent>\n      </Card>\n\n      {/* Categories Overview */}\n      <Card sx={{ mb: 3 }}>\n        <CardContent>\n          <Typography variant=\"h6\" gutterBottom>\n            Document Categories\n          </Typography>\n          <Grid container spacing={2}>\n            {categories.map((category) => (\n              <Grid item key={category.category}>\n                <Chip\n                  icon={<FolderIcon />}\n                  label={`${category.category} (${category.count})`}\n                  onClick={() => setFilters({ ...filters, category: category.category })}\n                  sx={{\n                    bgcolor: getCategoryColor(category.category),\n                    color: 'white',\n                    '&:hover': {\n                      bgcolor: getCategoryColor(category.category),\n                      opacity: 0.8\n                    }\n                  }}\n                />\n              </Grid>\n            ))}\n          </Grid>\n        </CardContent>\n      </Card>\n\n      {/* Documents List */}\n      <Card>\n        <CardContent>\n          <Typography variant=\"h6\" gutterBottom>\n            Documents ({pagination.total})\n          </Typography>\n          \n          {loading ? (\n            <Box display=\"flex\" justifyContent=\"center\" p={3}>\n              <CircularProgress />\n            </Box>\n          ) : documents.length === 0 ? (\n            <Alert severity=\"info\">\n              No documents found. Try adjusting your search criteria.\n            </Alert>\n          ) : (\n            <List>\n              {documents.map((document) => (\n                <React.Fragment key={document.id}>\n                  <ListItem>\n                    <ListItemIcon>\n                      {getDocumentIcon(document)}\n                    </ListItemIcon>\n                    <ListItemText\n                      primary={\n                        <Box display=\"flex\" alignItems=\"center\" gap={1}>\n                          <Typography variant=\"subtitle1\">\n                            {document.name}\n                          </Typography>\n                          <Chip\n                            size=\"small\"\n                            label={document.category}\n                            sx={{\n                              bgcolor: getCategoryColor(document.category),\n                              color: 'white',\n                              fontSize: '0.75rem'\n                            }}\n                          />\n                          {document.isShared && (\n                            <Chip\n                              size=\"small\"\n                              icon={<ShareIcon />}\n                              label=\"Shared\"\n                              color=\"primary\"\n                              variant=\"outlined\"\n                            />\n                          )}\n                          {document.isEncrypted && (\n                            <Chip\n                              size=\"small\"\n                              icon={<SecurityIcon />}\n                              label=\"Encrypted\"\n                              color=\"secondary\"\n                              variant=\"outlined\"\n                            />\n                          )}\n                        </Box>\n                      }\n                      secondary={\n                        <Box>\n                          <Typography variant=\"body2\" color=\"text.secondary\">\n                            {formatFileSize(document.size)} • \n                            Uploaded {format(new Date(document.uploadedAt), 'MMM dd, yyyy')}\n                          </Typography>\n                          {document.tags.length > 0 && (\n                            <Box sx={{ mt: 1 }}>\n                              {document.tags.map((tag) => (\n                                <Chip\n                                  key={tag}\n                                  size=\"small\"\n                                  label={tag}\n                                  variant=\"outlined\"\n                                  sx={{ mr: 0.5, mb: 0.5 }}\n                                />\n                              ))}\n                            </Box>\n                          )}\n                        </Box>\n                      }\n                    />\n                    <ListItemSecondaryAction>\n                      <Box display=\"flex\" gap={1}>\n                        <Tooltip title=\"View Document\">\n                          <IconButton onClick={() => viewDocument(document)}>\n                            <ViewIcon />\n                          </IconButton>\n                        </Tooltip>\n                        {document.accessLevel !== 'read' && (\n                          <Tooltip title=\"Download Document\">\n                            <IconButton onClick={() => downloadDocument(document)}>\n                              <DownloadIcon />\n                            </IconButton>\n                          </Tooltip>\n                        )}\n                        <Tooltip title=\"Comments\">\n                          <IconButton\n                            onClick={() => {\n                              setSelectedDocument(document);\n                              loadDocumentComments(document.id);\n                              setShowCommentsDialog(true);\n                            }}\n                          >\n                            <CommentIcon />\n                          </IconButton>\n                        </Tooltip>\n                        <IconButton onClick={(e) => handleMenuClick(e, document)}>\n                          <MoreVertIcon />\n                        </IconButton>\n                      </Box>\n                    </ListItemSecondaryAction>\n                  </ListItem>\n                  <Divider />\n                </React.Fragment>\n              ))}\n            </List>\n          )}\n\n          {/* Load More Button */}\n          {pagination.hasMore && (\n            <Box display=\"flex\" justifyContent=\"center\" mt={2}>\n              <Button\n                variant=\"outlined\"\n                onClick={() => setPagination(prev => ({ ...prev, offset: prev.offset + prev.limit }))}\n                disabled={loading}\n              >\n                Load More\n              </Button>\n            </Box>\n          )}\n        </CardContent>\n      </Card>\n\n      {/* Document Menu */}\n      <Menu\n        anchorEl={anchorEl}\n        open={Boolean(anchorEl)}\n        onClose={handleMenuClose}\n      >\n        <MenuItem onClick={() => {\n          if (selectedDocumentForMenu) {\n            viewDocument(selectedDocumentForMenu);\n          }\n          handleMenuClose();\n        }}>\n          <ListItemIcon><ViewIcon /></ListItemIcon>\n          View\n        </MenuItem>\n        {selectedDocumentForMenu?.accessLevel !== 'read' && (\n          <MenuItem onClick={() => {\n            if (selectedDocumentForMenu) {\n              downloadDocument(selectedDocumentForMenu);\n            }\n            handleMenuClose();\n          }}>\n            <ListItemIcon><DownloadIcon /></ListItemIcon>\n            Download\n          </MenuItem>\n        )}\n        <MenuItem onClick={() => {\n          if (selectedDocumentForMenu) {\n            setSelectedDocument(selectedDocumentForMenu);\n            loadDocumentComments(selectedDocumentForMenu.id);\n            setShowCommentsDialog(true);\n          }\n          handleMenuClose();\n        }}>\n          <ListItemIcon><CommentIcon /></ListItemIcon>\n          Comments\n        </MenuItem>\n        <MenuItem onClick={() => {\n          if (selectedDocumentForMenu) {\n            setSelectedDocument(selectedDocumentForMenu);\n            setShowShareDialog(true);\n          }\n          handleMenuClose();\n        }}>\n          <ListItemIcon><ShareIcon /></ListItemIcon>\n          Share\n        </MenuItem>\n      </Menu>\n\n      {/* Document View Dialog */}\n      <Dialog\n        open={showDocumentDialog}\n        onClose={() => setShowDocumentDialog(false)}\n        maxWidth=\"md\"\n        fullWidth\n      >\n        <DialogTitle>\n          <Box display=\"flex\" alignItems=\"center\" justifyContent=\"space-between\">\n            <Typography variant=\"h6\">\n              {selectedDocument?.name}\n            </Typography>\n            <IconButton onClick={() => setShowDocumentDialog(false)}>\n              <CloseIcon />\n            </IconButton>\n          </Box>\n        </DialogTitle>\n        <DialogContent>\n          {selectedDocument && (\n            <Box>\n              <Grid container spacing={2} sx={{ mb: 2 }}>\n                <Grid item xs={12} md={6}>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Category: {selectedDocument.category}\n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Size: {formatFileSize(selectedDocument.size)}\n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Uploaded: {format(new Date(selectedDocument.uploadedAt), 'MMM dd, yyyy HH:mm')}\n                  </Typography>\n                </Grid>\n                <Grid item xs={12} md={6}>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Access Level: {selectedDocument.accessLevel}\n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Version: {selectedDocument.version}\n                  </Typography>\n                  {selectedDocument.expiresAt && (\n                    <Typography variant=\"body2\" color=\"text.secondary\">\n                      Expires: {format(new Date(selectedDocument.expiresAt), 'MMM dd, yyyy')}\n                    </Typography>\n                  )}\n                </Grid>\n              </Grid>\n              \n              {selectedDocument.thumbnailUrl ? (\n                <Box display=\"flex\" justifyContent=\"center\" mb={2}>\n                  <img\n                    src={selectedDocument.thumbnailUrl}\n                    alt={selectedDocument.name}\n                    style={{ maxWidth: '100%', maxHeight: '400px', objectFit: 'contain' }}\n                  />\n                </Box>\n              ) : (\n                <Box display=\"flex\" justifyContent=\"center\" alignItems=\"center\" height={200} bgcolor=\"grey.100\" mb={2}>\n                  {getDocumentIcon(selectedDocument)}\n                  <Typography variant=\"body2\" color=\"text.secondary\" sx={{ ml: 1 }}>\n                    Preview not available\n                  </Typography>\n                </Box>\n              )}\n\n              {selectedDocument.tags.length > 0 && (\n                <Box>\n                  <Typography variant=\"subtitle2\" gutterBottom>\n                    Tags:\n                  </Typography>\n                  {selectedDocument.tags.map((tag) => (\n                    <Chip\n                      key={tag}\n                      size=\"small\"\n                      label={tag}\n                      variant=\"outlined\"\n                      sx={{ mr: 0.5, mb: 0.5 }}\n                    />\n                  ))}\n                </Box>\n              )}\n            </Box>\n          )}\n        </DialogContent>\n        <DialogActions>\n          {selectedDocument?.accessLevel !== 'read' && (\n            <Button\n              onClick={() => selectedDocument && downloadDocument(selectedDocument)}\n              startIcon={<DownloadIcon />}\n            >\n              Download\n            </Button>\n          )}\n          <Button onClick={() => setShowDocumentDialog(false)}>\n            Close\n          </Button>\n        </DialogActions>\n      </Dialog>\n\n      {/* Comments Dialog */}\n      <Dialog\n        open={showCommentsDialog}\n        onClose={() => setShowCommentsDialog(false)}\n        maxWidth=\"md\"\n        fullWidth\n      >\n        <DialogTitle>\n          Comments - {selectedDocument?.name}\n        </DialogTitle>\n        <DialogContent>\n          <Box sx={{ mb: 2 }}>\n            <TextField\n              fullWidth\n              multiline\n              rows={3}\n              placeholder=\"Add a comment...\"\n              value={newComment}\n              onChange={(e) => setNewComment(e.target.value)}\n            />\n            <Box display=\"flex\" justifyContent=\"flex-end\" mt={1}>\n              <Button\n                variant=\"contained\"\n                onClick={addComment}\n                startIcon={<SendIcon />}\n                disabled={!newComment.trim()}\n              >\n                Add Comment\n              </Button>\n            </Box>\n          </Box>\n          \n          <Divider sx={{ mb: 2 }} />\n          \n          <List>\n            {documentComments.map((comment) => (\n              <ListItem key={comment.id} alignItems=\"flex-start\">\n                <ListItemIcon>\n                  <Avatar sx={{ width: 32, height: 32 }}>\n                    <PersonIcon />\n                  </Avatar>\n                </ListItemIcon>\n                <ListItemText\n                  primary={\n                    <Box display=\"flex\" alignItems=\"center\" gap={1}>\n                      <Typography variant=\"subtitle2\">\n                        {comment.userType === 'tenant' ? 'You' : 'Property Manager'}\n                      </Typography>\n                      <Typography variant=\"caption\" color=\"text.secondary\">\n                        {format(new Date(comment.createdAt), 'MMM dd, yyyy HH:mm')}\n                      </Typography>\n                      {comment.isPrivate && (\n                        <Chip size=\"small\" label=\"Private\" color=\"secondary\" />\n                      )}\n                    </Box>\n                  }\n                  secondary={comment.comment}\n                />\n              </ListItem>\n            ))}\n          </List>\n          \n          {documentComments.length === 0 && (\n            <Alert severity=\"info\">\n              No comments yet. Be the first to add a comment!\n            </Alert>\n          )}\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={() => setShowCommentsDialog(false)}>\n            Close\n          </Button>\n        </DialogActions>\n      </Dialog>\n\n      {/* Snackbar for notifications */}\n      <Snackbar\n        open={snackbar.open}\n        autoHideDuration={6000}\n        onClose={() => setSnackbar({ ...snackbar, open: false })}\n      >\n        <Alert\n          onClose={() => setSnackbar({ ...snackbar, open: false })}\n          severity={snackbar.severity}\n          sx={{ width: '100%' }}\n        >\n          {snackbar.message}\n        </Alert>\n      </Snackbar>\n    </Box>\n  );\n};\n\nexport default SecureDocumentAccess;